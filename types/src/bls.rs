#![cfg(any(test, feature = "bls-support"))]
use crate::errors::*;
use crate::istanbul::*;
use ethereum_types::*;
use std::convert::TryFrom;

use bls_crypto::{
    hash_to_curve::try_and_increment::DIRECT_HASH_TO_G1, PublicKey as BLSPublicKey,
    Signature as BLSSignature,
};
use ark_serialize::CanonicalDeserialize;

pub fn verify_aggregated_seal(
    header_hash: H256,
    validators: &[ValidatorData],
    seal: &IstanbulAggregatedSeal,
) -> Result<(), Error> {
    let public_keys: Vec<BLSPublicKey> = validators
        .iter()
        .enumerate()
        .filter(|(i, _)| seal.bitmap.bit(*i))
        .map(|(_, validator)| BLSPublicKey::try_from(validator.public_key))
        .collect::<Result<_, _>>()
        .map_err(|_| Kind::BlsInvalidPublicKey {})?;
    let expected_quorum_size = min_quorum_size(validators.len());
    if public_keys.len() < expected_quorum_size {
        return Err(Kind::MissingSeals {
            current: public_keys.len(),
            expected: expected_quorum_size,
        }
        .into());
    }
    let proposal_seal = prepare_commited_seal(&header_hash, &seal.round);
    let bls_sig = deserialize_signature(&seal.signature)?;
    let apk = BLSPublicKey::aggregate(public_keys);
    match apk.verify(&proposal_seal, &[], &bls_sig, &*DIRECT_HASH_TO_G1) {
        Ok(_) => Ok(()),
        Err(_) => Err(Kind::BlsVerifyError.into()),
    }
}

fn prepare_commited_seal(hash: &H256, round: &U128) -> Vec<u8> {
    let leading_zero_bytes: usize = (round.leading_zeros() / 8) as usize;
    let round_bytes = round.as_u128().to_be_bytes();
    let commit_bytes = [IstanbulMsg::Commit as u8];
    [
        &hash[..],
        &round_bytes[leading_zero_bytes..],
        &commit_bytes[..],
    ]
    .concat()
}

fn deserialize_signature(signature: &[u8]) -> Result<BLSSignature, Error> {
    BLSSignature::deserialize(signature).map_err(|e| Kind::BlsInvalidSignature.context(e).into())
}

impl std::convert::TryFrom<SerializedPublicKey> for BLSPublicKey {
    type Error = ark_serialize::SerializationError;
    fn try_from(spk: SerializedPublicKey) -> Result<Self, Self::Error> {
        BLSPublicKey::deserialize(spk.as_bytes())
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use ethereum_types::*;
    use std::str::FromStr;

    #[test]
    fn prepare_committed_seal() {
        //generated by go code
        let round = U128::from(5315026794705956357 as u64);
        let hash =
            H256::from_str("0000000000000000000000000000000000000000000000001503d3adee8d1938")
                .unwrap();
        let expected_seal: Vec<u8> = vec![
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 21, 3, 211,
            173, 238, 141, 25, 56, 73, 194, 196, 181, 166, 33, 174, 5, 2,
        ];

        let seal = prepare_commited_seal(&hash, &round);
        assert_eq!(seal, expected_seal);
    }

    #[test]
    fn to_bls_public_key() {
        let spk = SerializedPublicKey::from_str ("0x4fa3f67fc913878b068d1fa1cdddc54913d3bf988dbe5a36a20fa888f20d4894c408a6773f3d7bde11154f2a3076b700d345a42fd25a0e5e83f4db5586ac7979ac2053cd95d8f2efd3e959571ceccaa743e02cf4be3f5d7aaddb0b06fc9aff00").unwrap();
        let bls_public = bls_crypto::PublicKey::try_from(spk).unwrap();
    }
}
